{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Selamat Datang","text":"<p>Dokumen ini adalah dokumentasi dari base project Go. Silahkan melanjutkan bacaan dengan menu navigasi yang ada.</p>"},{"location":"openapi-docs/","title":"Dokumentasi OpenAPI 3.1","text":"<p>Dokumentasi dapat dilihat pada <code>{baseUrl}/doc/api</code>. Untuk mengubah dokumentasi tersebut, silahkan mengubah berkas <code>oas3.yml</code> sesuai dengan spesifikasi OpenAPI 3.1.0.</p>"},{"location":"project-docs/","title":"Dokumentasi Project","text":"<p>Dokumentasi dapat dilihat pada <code>{baseUrl}/doc/project</code>. Untuk mengubah dokumentasi tersebut, silahkan mengubah source code pada <code>docs</code> lalu build pada direktori <code>static/mkdocs</code>.</p>"},{"location":"struktur-direktori/","title":"Struktur Direktori","text":"<p>Base Go ini didesain sedemikian rupa sehingga cocok untuk aplikasi berskala besar maupun kecil dengan sifat yang modular. Secara default, arsitektur yang digunakan adalah Modular Monolithic dengan Aggregate Pattern maupun Transaction Script Pattern yang ada pada Domain-Driven Design (DDD).</p> <p>Sebagian besar kode disimpan pada folder internal untuk menjaga agar penggunaan nama/istilah yang sama tidak terimpor secara tidak sengaja pada Bounded Context/modul lain.</p>"},{"location":"struktur-direktori/#direktori-root","title":"Direktori Root","text":""},{"location":"struktur-direktori/#direktori-bootstrap","title":"Direktori <code>bootstrap</code>","text":"<p>Direktori ini berfungsi untuk melakukan setup pada config, event handler, dan routing pada aplikasi dan setiap modul di dalam aplikasi.</p>"},{"location":"struktur-direktori/#direktori-docs","title":"Direktori <code>docs</code>","text":"<p>Direktori ini berisi terkait dokumentasi penggunaan base project berupa markdown yang dicompile menggunakan MkDocs dengan tema mkdocs-material.</p>"},{"location":"struktur-direktori/#direktori-examples","title":"Direktori <code>examples</code>","text":"<p>Direktori ini berisi mengenai kode snippet untuk contoh pada setiap kasus, misal penggunaan autentikasi, dan lain-lain.</p>"},{"location":"struktur-direktori/#direktori-modules","title":"Direktori <code>modules</code>","text":"<p>Direktori ini adalah core dari aplikasi yang akan dieksplor lebih detail pada bagian selanjutnya. Sebagian besar dari kode yang akan Anda tulis ada pada direktori ini.</p>"},{"location":"struktur-direktori/#direktori-pkg","title":"Direktori <code>pkg</code>","text":"<p>Direktori ini berisikan shared library yang dapat digunakan oleh semua modul pada aplikasi.</p>"},{"location":"struktur-direktori/#direktori-script","title":"Direktori <code>script</code>","text":"<p>Direktori ini berisikan kode sumber untuk automated script yang membantu dalam pengembangan aplikasi.</p>"},{"location":"struktur-direktori/#direktori-modules_1","title":"Direktori <code>modules</code>","text":"<p>Direktori <code>modules</code> berisi modul-modul yang ada dalam aplikasi. Setiap modul merupakan implementasi dari sebuah Bounded Context pada Domain-Driven Design. Direktori ini harus berisi beberapa folder yang menyatakan nama dari modul. Struktur setiap modul disesuaikan dengan Onion/Hexagonal/Clean Architecture dengan Command Query Responsibility Segregation (CQRS) Pattern yang terdiri dari direktori sebagai berikut:</p>"},{"location":"struktur-direktori/#direktori-internalappconfig","title":"Direktori <code>internal/app/config</code>","text":"<p>Direktori ini berisikan konfigurasi dari setiap modul. Alur yang dikerjakan dari layer ini adalah sebagai berikut:</p> <ol> <li>Mengambil data environment variable</li> <li>Melakukan mapping ke struct config</li> <li>Inject config agar dapat dipakai di seluruh aplikasi</li> </ol>"},{"location":"struktur-direktori/#direktori-internalappcontrollers","title":"Direktori <code>internal/app/controllers</code>","text":"<p>Direktori ini berisikan handler dari request yang masuk ke dalam aplikasi. Alur yang dikerjakan dari layer ini adalah sebagai berikut:</p> <ol> <li>Menerima request masuk</li> <li>Validasi request (request body/query/params)</li> <li>Memanggil command/query yang diperlukan untuk mengerjakan use case</li> <li>Handle error yang dikeluarkan oleh command/query terkait</li> <li>Memberikan response terhadap request</li> </ol>"},{"location":"struktur-direktori/#direktori-internalappcommands","title":"Direktori <code>internal/app/commands</code>","text":"<p>Direktori ini berisikan command handler yang memiliki sifat mengubah state dari sistem yang artinya melakukan perubahan data yang disimpan pada database sistem. Alur yang dikerjakan dari layer ini adalah sebagai berikut:</p> <ol> <li>Menerima request masuk dari controller</li> <li>Memanggil repository terkait untuk mengambil state eksisting pada sebuah agregat</li> <li>Memanggil exported/public method yang ada pada agregat untuk mengubah state</li> <li>(Opsional) Publish event ke event dispatcher</li> <li>Memanggil repository untuk menyimpan state ke database</li> </ol>"},{"location":"struktur-direktori/#direktori-internalapplisteners","title":"Direktori <code>internal/app/listeners</code>","text":"<p>Direktori ini memiliki banyak kesamaan peran dan alur seperti <code>internal/app/commands</code>. Perbedaannya adalah listeners dipanggil oleh aplikasi (lebih tepatnya event dispatcher) ketika event sudah dipublish. Listener tidak dapat memberikan return value apapun (void method) dikarenakan layer ini tidak dihandle oleh controller. Apapun hal yang ingin dicatat pada layer ini harus dilakukan melalui logging.</p>"},{"location":"struktur-direktori/#direktori-internalappqueries","title":"Direktori <code>internal/app/queries</code>","text":"<p>Direktori ini berisikan query object yang hanya bersifat read-only yang berarti tidak dapat mengubah state yang tersimpan pada sistem. Layer ini berperan untuk melayani use-case yang hanya membaca data. Alur kerja layer ini adalah sebagai berikut:</p> <ol> <li>Menerima panggilan dari controller</li> <li>Mengambil data dari database</li> <li>Mengembalikan nilainya ke controller</li> </ol>"},{"location":"struktur-direktori/#direktori-internalapproutes","title":"Direktori <code>internal/app/routes</code>","text":"<p>Direktori ini berisikan pengaturan routing dari setiap endpoint yang akan disediakan (method, middleware, URI, dan handler). Direktori ini juga berperan dalam memberikan implementasi konkrit ke Dependency Injection.</p>"},{"location":"struktur-direktori/#direktori-internalinfrastructures","title":"Direktori <code>internal/infrastructures</code>","text":"<p>Direktori ini berisikan implementasi dari interface yang didefinisikan pada query handler, repository, atau lainnya.</p>"},{"location":"struktur-direktori/#direktori-internaldomainservices","title":"Direktori <code>internal/domain/services</code>","text":"<p>Jika Anda menggunakan Transaction Script Pattern, maka direktori ini memiliki peran sebagai berikut:</p> <ul> <li>Melakukan validasi business rules/invariant</li> </ul> <p>Jika Anda menggunakan Aggregate Pattern, maka penggunaan dari domain services hanya untuk melakukan komputasi dari beberapa agregat dengan alur sebagai berikut:</p> <ol> <li>Memanggil repositori dari beberapa agregat</li> <li>Melakukan komputasi</li> <li>Mengembalikan nilai</li> </ol>"},{"location":"struktur-direktori/#direktori-internaldomainrepositories","title":"Direktori <code>internal/domain/repositories</code>","text":"<p>Direktori ini berisikan interface untuk mendapatkan dan menyimpan data yang diperlukan oleh domain services/command handler/event listener dari setiap agregat.</p>"},{"location":"struktur-direktori/#struktur-direktori-khusus-aggregate-pattern","title":"Struktur Direktori Khusus Aggregate Pattern","text":""},{"location":"struktur-direktori/#direktori-internaldomainentities","title":"Direktori <code>internal/domain/entities</code>","text":"<p>Direktori ini berisikan entitas maupun aggregate root dari aplikasi yang berfungsi untuk mengenkapsulasi business rules/invariant dan menjaga statenya selalu valid.</p>"},{"location":"struktur-direktori/#direktori-internaldomainevents","title":"Direktori <code>internal/domain/events</code>","text":"<p>Direktori ini berisikan event yang dipublish oleh aggregate root.</p>"},{"location":"struktur-direktori/#direktori-internaldomainvalueobjects","title":"Direktori <code>internal/domain/valueobjects</code>","text":"<p>Direktori ini berisikan value object yang digunakan untuk mengenkapsulasi business rules/invariant dan menjaga statenya selalu valid.</p>"},{"location":"basics/authentication/","title":"Authentication","text":""},{"location":"basics/authentication/#melakukan-autentikasi-manual","title":"Melakukan Autentikasi Manual","text":"<p>Anda dapat melakukan autentikasi dengan memanggil fungsi <code>Login()</code> pada package <code>its.ac.id/base-go/pkg/auth/services</code>. Fungsi tersebut menerima argumen berupa <code>*gin.Context</code> dan instance user yang akan dilakukan proses autentikasi. Setelah autentikasi berhasil, Anda harus melakukan generate ulang user session untuk mencegah session fixation.</p> <pre><code>func HandleLogin(ctx *gin.Context) {\n    // Melakukan login\n    if err := services.Login(ctx, user); err != nil {\n        ctx.JSON(http.StatusInternalServerError, gin.H{\n            \"code\":    http.StatusInternalServerError,\n            \"message\": \"login_failed\",\n            \"data\":    nil,\n        })\n        return\n    }\n\n    // Regenerate session ID dan menyimpannya\n    sess := session.Default(ctx)\n    sess.Regenerate()\n    if err := sess.Save(); err != nil {\n        ctx.JSON(http.StatusInternalServerError, gin.H{\n            \"code\":    http.StatusInternalServerError,\n            \"message\": \"unable_to_save_session\",\n            \"data\":    nil,\n        })\n        return\n    }\n\n    // Mengganti session ID pada cookie ke nilai yang baru\n    session.AddCookieToResponse(ctx, sess.Id())\n\n    // Response login berhasil\n    ctx.JSON(http.StatusOK, gin.H{\n        \"code\":    http.StatusOK,\n        \"message\": \"login_success\",\n        \"data\":    nil,\n    })\n}\n</code></pre> <p>Route yang ingin diproteksi dapat diproteksi dengan menggunakan middleware <code>Auth()</code> pada package <code>its.ac.id/base-go/pkg/auth/middleware</code>.</p> <pre><code>func registerRoutes(r *gin.Engine) {\n    g := r.Group(\"/auth\")\n    authController := controllers.NewAuthController()\n\n    g.GET(\"/user\", middleware.Auth(), authController.User)\n}\n</code></pre>"},{"location":"basics/authentication/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<p>Metode ini mengizinkan Anda untuk mengautentikasi pengguna menggunakan header <code>Authorization: Basic xxxxxx</code>.</p>"},{"location":"basics/authentication/#prasyarat","title":"Prasyarat","text":"<p>Anda perlu membuat adapter untuk mendapatkan user dari penyimpanan yang mengimplementasikan interface berikut:</p> <pre><code>type UserRepository interface {\n    FindByUsername(username string) (*User, error)\n}\n</code></pre> <p>Secara bawaan, tersedia adapter untuk mendapatkan user dari sebuah slice/array:</p> <pre><code>func initiateUserRepository() contracts.UserRepository {\n    // Load semua user dari env atau hardcoded\n    users := make([]adapters.SliceUser, 0)\n    users = append(users, adapters.SliceUser{\n        Id:             \"9a08d515-522c-4f5b-954a-13755bf61b2f\",\n        Username:       \"zydhanlinnar11\",\n        HashedPassword: \"$2a$10$nY0Xkk.8zTUNQFL4fiKCKe5djphBJN5AyAq.LDnxKwOWJ1W/D9Txa\",\n    })\n\n    // Inisialisasi userRepo dengan adapter untuk mendapatkan user dari slice / array\n    return adapters.NewSliceUserRepository(users)\n}\n</code></pre>"},{"location":"basics/authentication/#proses-autentikasi","title":"Proses Autentikasi","text":"<p>Anda perlu menginisiasi middleware basic auth dengan memberikan argumen berupa user repository di atas kemudian menggunakannya pada handler function pada rute yang ingin diproteksi.</p> <pre><code>func basicAuthRoutes(r *gin.Engine) {\n    // Inisiaisasi middleware dengan userRepo\n    authMiddleware := middleware.NewBasicAuthMiddleware(initiateUserRepository())\n\n    // Tambahkan middleware ke route yang ingin di-protect\n    r.GET(\"/basic-auth\", authMiddleware.Handle(), func(c *gin.Context) {\n        user := services.User(c)\n\n        c.JSON(http.StatusOK, gin.H{\n            \"code\":    http.StatusOK,\n            \"message\": \"user\",\n            \"data\": gin.H{\n                \"id\":          user.Id(),\n                \"active_role\": nil,\n                \"roles\":       make([]string, 0),\n            },\n        })\n    })\n}\n</code></pre>"},{"location":"basics/authentication/#mendapatkan-user","title":"Mendapatkan User","text":"<p>User dapat diperoleh melalui method <code>User()</code> dengan argumen <code>*gin.Context</code> pada package <code>its.ac.id/base-go/pkg/auth/services</code>.</p> <pre><code>r.GET(\"/basic-auth\", authMiddleware.Handle(), func(c *gin.Context) {\n    user := services.User(c)\n\n    c.JSON(http.StatusOK, gin.H{\n        \"code\":    http.StatusOK,\n        \"message\": \"user\",\n        \"data\": gin.H{\n            \"id\":          user.Id(),\n            \"active_role\": nil,\n            \"roles\":       make([]string, 0),\n        },\n    })\n})\n</code></pre>"},{"location":"basics/authentication/#log-out","title":"Log Out","text":"<p>Untuk melakukan log out, Anda dapat memanggil fungsi <code>Logout()</code>. Direkomendasikan untuk invalidate user session dan melakukan regenerate CSRF token setelah proses log out.</p> <pre><code>func HandleLogout(ctx *gin.Context) {\n    // Melakukan proses log out\n    if err = services.Logout(ctx); err != nil {\n        ctx.JSON(http.StatusInternalServerError, gin.H{\n            \"code\":    http.StatusInternalServerError,\n            \"message\": \"logout_failed\",\n            \"data\":    nil,\n        })\n        return\n    }\n\n    // Invalidate session, regenerate CSRF token, dan menyimpannya\n    sess := session.Default(ctx)\n    sess.Invalidate()\n    sess.RegenerateCSRFToken()\n    if err := sess.Save(); err != nil {\n        ctx.JSON(http.StatusInternalServerError, gin.H{\n            \"code\":    http.StatusInternalServerError,\n            \"message\": \"unable_to_save_session\",\n            \"data\":    nil,\n        })\n        return\n    }\n\n    // Mengganti session ID pada cookie ke nilai yang baru\n    session.AddCookieToResponse(ctx, sess.Id())\n\n    // Response logout berhasil\n    ctx.JSON(http.StatusOK, gin.H{\n        \"code\":    http.StatusOK,\n        \"message\": \"logout_success\",\n        \"data\":    nil,\n    })\n}\n</code></pre>"},{"location":"basics/controllers/","title":"Controllers","text":"<p>Daripada mendefinisikan semua logika penanganan permintaan Anda di file <code>routes.go</code>, Anda mungkin ingin mengatur perilaku ini menggunakan kelas \"controllers\". Controller dapat mengelompokkan logika handle request terkait ke dalam satu kelas. Misalnya, kelas UserController mungkin menangani semua request yang terkait dengan pengguna, termasuk menampilkan, membuat, memperbarui, dan menghapus pengguna. Secara default, controllers disimpan di direktori internal/presentation/controllers pada setiap modul.</p>"},{"location":"basics/controllers/#controller-dasar","title":"Controller Dasar","text":"<p>Untuk membuat controller baru dengan cepat, Anda dapat menjalankan command <code>make:controller</code>.</p> <pre><code>go run ./script/script.go make:controller &lt;nama modul&gt; &lt;nama controller&gt;\n</code></pre> <p>Nama controller harus berupa pascal case tanpa suffix \"Controller\"</p> <p>Berikut adalah contoh controller sederhana yang memiliki satu public/exported method.</p> <pre><code>package controllers\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/samber/do\"\n)\n\ntype SemesterController struct {\n    i *do.Injector\n}\n\nfunc NewSemesterController() *SemesterController {\n    i := do.DefaultInjector\n    return &amp;SemesterController{i: i}\n}\n\n\nfunc (c *SemesterController) Hello(ctx *gin.Context) {\n    ctx.JSON(200, gin.H{\n        \"message\": \"Hello SemesterController\",\n    })\n}\n</code></pre> <p>Dengan demikian, kode pada <code>registerRoutes()</code> dapat diubah dengan inisiasi dan memanggil controller.</p> <pre><code>func registerRoutes(r *gin.Engine) {\n    g := r.Group(routePrefix)\n\n    // Controller initialization\n    smtController := controllers.NewSemesterController()\n\n    // Register routes below\n    g.GET(\"/hello\", smtController.Hello)\n}\n</code></pre>"},{"location":"basics/csrf/","title":"Proteksi CSRF","text":""},{"location":"basics/csrf/#pengenalan","title":"Pengenalan","text":"<p>CSRF adalah jenis eksploitasi berbahaya di mana perintah tidak sah dilakukan atas nama pengguna yang diautentikasi.</p>"},{"location":"basics/csrf/#penjelasan-vulnerability","title":"Penjelasan Vulnerability","text":"<p>Bayangkan aplikasi anda memiliki rute <code>/user/email</code> yang menerima <code>POST</code> request untuk mengubah email pengguna. Kemunghkinan rute ini menginginkan field berupa <code>email</code> yang berisikan alamat email dari pengguna yang ingin digunakan. Tanpa proteksi CSRF, website lain dapat membuat form HTML yang mengarahkan ke rute tersebut dan mengganti email dari pengguna tersebut.</p> <pre><code>&lt;form action=\"https://your-application.com/user/email\" method=\"POST\"&gt;\n  &lt;input type=\"email\" value=\"malicious-email@example.com\" /&gt;\n&lt;/form&gt;\n\n&lt;script&gt;\n  document.forms[0].submit()\n&lt;/script&gt;\n</code></pre> <p>Jika web tersebut otomatis submit form pada saat laman dimuat, pengguna hanya perlu mengunjungi website tersebut dan emailnya akan berubah. Untuk mencegah ini, kita wajib menginpeksi request dengan method selain <code>GET</code>, <code>HEAD</code>, dan <code>OPTIONS</code> dan mencocokkan dengan secret yang tidak dapat diakses oleh website lain.</p>"},{"location":"basics/csrf/#mencegah-csrf","title":"Mencegah CSRF","text":"<p>Base project ini otomatis melakukan generate CSRF token untuk setiap session yang ada. Token ini digunakan untuk melakukan verifikasi. Token dapat diakses oleh front-end dengan mengambil nilai cookie <code>CSRF-TOKEN</code> yang akan diberikan oleh back-end untuk setiap request. Oleh karena itu, sebelum pengguna melakukan log in, front-end perlu memanggil route <code>/csrf-cookie</code>. Route tersebut hanya berfungsi untuk memberikan nilai cookie tersebut. Setelah itu, untuk setiap request dari front-end dengan method selain dari yang disebutkan di atas perlu memberikan nilai CSRF token tersebut melalui header <code>X-CSRF-TOKEN</code>.</p> <pre><code>function getCookie(key) {\n  const cookies = document.cookie.split('; ')\n  for (let i = 0; i &lt; cookies.length; i++) {\n    const [cKey, value] = cookies[i].split('=')\n    if (key === cKey) return value\n  }\n  return null\n}\n\n// Memanggil POST request\nfetch('/user/email', {\n  credentials: 'include',\n  method: 'POST',\n  body: JSON.stringify({ email: 'dptsi@its.ac.id' }),\n  headers: {\n    'X-CSRF-TOKEN': getCookie('CSRF-TOKEN'),\n  },\n})\n</code></pre>"},{"location":"basics/modul/","title":"Modul","text":"<p>Aplikasi modular monolithic dibagi menjadi beberapa modul yang merupakan implementasi dari Bounded Context pada Domain-Driven Desain. Pada base project ini, modul didesain sedemikian rupa sehingga memiliki sifat loosely coupled dari/ke aplikasi utama maupun modul lainnya.</p>"},{"location":"basics/modul/#aturan-dalam-modul","title":"Aturan Dalam Modul","text":"<p>Untuk menjaga agar modul tetap bersifat loosely coupled, maka aturan-aturan berikut harus dipenuhi:</p> <ul> <li>Modul hanya diizinkan mengimpor apa yang ada pada <code>bootstrap</code> (terutama hook) dan <code>pkg</code> (shared library) dari aplikasi utama</li> <li>Setiap modul dilarang mengimpor apa yang ada pada modul lain</li> <li>Setiap modul wajib memiliki nama dan URI prefix yang unik</li> <li>Nama modul wajib menggunakan huruf kecil dan snake case</li> </ul>"},{"location":"basics/modul/#pembuatan-modul","title":"Pembuatan modul","text":"<p>Modul dapat dibuat dengan menjalankan command berikut:</p> <pre><code>go run ./script/script.go make:module &lt;nama modul&gt;\n</code></pre> <p>Anda akan diberikan pertanyaan sebagai berikut setelah menjalankan command untuk memilih pattern yang digunakan:</p> <pre><code>Do you want to use transaction script instead of aggregate pattern? (y/N):\n</code></pre> <p>Jika sudah, maka modul akan ada pada direktori <code>modules</code>.</p>"},{"location":"basics/modul/#mendaftarkan-modul","title":"Mendaftarkan Modul","text":"<p>Modul dapat didaftarkan/diaktifkan dengan mengimpornya pada <code>main.go</code>. Anda hanya perlu memberi alias <code>_</code> pada modul yang diimpor.</p> <pre><code>\nimport (\n    // Modules\n    _ \"its.ac.id/base-go/modules/auth\"\n    _ \"its.ac.id/base-go/modules/&lt;nama modul&gt;\" // Modul baru\n)\n</code></pre>"},{"location":"basics/modul/#menonaktifkan-modul","title":"Menonaktifkan Modul","text":"<p>Modul dapat dinonaktifkan tanpa perlu menghapus codenya dengan menghapus/memberi komentar pada baris impor di <code>main.go</code>.</p>"},{"location":"basics/routing/","title":"Routing","text":""},{"location":"basics/routing/#routing-dasar","title":"Routing Dasar","text":"<p>Routing pada base project ini menggunakan gin-gonic sebagai enginenya. Pada saat modul dibuat, prefix yang digunakan adalah nama modul dengan underscore (<code>_</code>) yang direplace dengan dash (<code>-</code>). Anda dapat mengubah prefix tersebut melalui konstanta <code>routePrefix</code>. Routing dapat diatur pada berkas <code>internal/app/routes/routes.go</code> di fungsi <code>registerRoutes()</code>.</p> <pre><code>const routePrefix = \"/nama-modul\"\n</code></pre> <p>Handler pada Gin pada dasarnya sederhana yaitu dengan memanggil method sesuai dengan HTTP method dengan parameter uri, serta handler.</p> <pre><code>g := r.Group(routePrefix)\n\n// Register routes below\ng.GET(\"/test\", func(c *gin.Context) {\n    c.JSON(200, gin.H{\n        \"message\": \"test\",\n    })\n})\n</code></pre>"},{"location":"basics/routing/#aturan-dalam-routing","title":"Aturan Dalam Routing","text":"<ul> <li>Prefix modul harus unik</li> <li>Prefix modul harus terdiri dari alfanumerik dan dash (<code>-</code>)</li> </ul>"},{"location":"basics/routing/#route-group","title":"Route Group","text":"<p>Route group berfungsi untuk memberi atribut seperti prefix maupun middleware pada beberapa route sekaligus tanpa perlu mendefinisikan pada setiap route. Untuk menggunakan group, anda perlu menggunakan method <code>Group()</code> pada pointer <code>gin.Engine</code>.</p> <pre><code>func registerRoutes(r *gin.Engine) {\n    // Membuat route group dengan prefix contoh-group\n    g := r.Group(\"/contoh-group\")\n}\n</code></pre>"},{"location":"basics/routing/#middleware","title":"Middleware","text":"<p>Middleware dapat digunakan pada route group dengan memanggil method <code>Use()</code> pada pointer <code>gin.RouterGroup</code>.</p> <pre><code>func registerRoutes(r *gin.Engine) {\n    // Membuat route group dengan prefix contoh-group\n    g := r.Group(\"/contoh-group\")\n\n    // Memasangkan middleware\n    g.Use(middleware.Auth())\n}\n</code></pre>"},{"location":"basics/routing/#cross-origin-resource-sharing-cors","title":"Cross-Origin Resource Sharing (CORS)","text":"<p>Base project ini otomatis menghandle request dengan method <code>OPTIONS</code> untuk melayani CORS. Akan tetapi, beberapa skenario mungkin memerlukan konfigurasi yang berbeda yang dapat diatur pada <code>.env</code>. Berikut konfigurasi bawaan dari base project ini:</p> <pre><code>CORS_PATH=*\nCORS_ALLOWED_METHODS=*\nCORS_ALLOWED_ORIGINS=*\nCORS_ALLOWED_HEADERS=\nCORS_EXPOSED_HEADERS=\nCORS_MAX_AGE=0\nCORS_SUPPORT_CREDENTIALS=false\n</code></pre>"},{"location":"basics/session/","title":"HTTP Session","text":""},{"location":"basics/session/#pengenalan","title":"Pengenalan","text":"<p>Karena aplikasi berbasis HTTP tidak memiliki state, session menyediakan cara untuk menyimpan informasi tentang pengguna di beberapa request. Informasi pengguna tersebut biasanya ditempatkan di penyimpanan/backend persisten yang dapat diakses dari request berikutnya.</p>"},{"location":"basics/session/#konfigurasi","title":"Konfigurasi","text":"<p>Konfigurasi dari session aplikasi disimpan pada berkas <code>bootstrap/web/web.go</code>. Secara bawaan, base project ini dikonfigurasi menggunakan SQLite sebagai adapter dari session. Adapter tersebut menentukan dimana data dari session akan disimpan untuk setiap request. Berikut adalah adapter bawaan yang ada di dalam base project ini:</p> <ul> <li>Firestore - session disimpan di dalam database Firestore</li> <li>GORM - session disimpan di dalam database yang didukung oleh GORM</li> </ul>"},{"location":"basics/session/#prasyarat-adapter","title":"Prasyarat Adapter","text":""},{"location":"basics/session/#firestore","title":"Firestore","text":"<p>Dengan menggunakan adapter ini, maka Anda perlu mengkonfigurasi Firestore dengan mengisi nilai <code>SESSION_FIRESTORE_PROJECT_ID</code> pada <code>.env</code> dengan nilai yang sesuai dengan Project ID yang akan digunakan.</p>"},{"location":"basics/session/#gorm","title":"GORM","text":"<p>Buat koneksi ke database sesuai dengan instruksi pada GORM kemudian panggil fungsi <code>adapters.NewGorm()</code> dengan argumen koneksi database yang telah dibuat.</p>"},{"location":"basics/session/#interaksi-dengan-session","title":"Interaksi Dengan Session","text":"<p>Instance dari session dapat diambil melalui method <code>Default()</code> pada <code>its.ac.id/base-go/pkg/session</code> dengan memberi argumen berupa <code>*gin.Context</code>.</p> <pre><code>package something\n\nimport \"its.ac.id/base-go/pkg/session\"\n\nfunc Handler(ctx *gin.Context) {\n    // Mendapatkan instance dari session saat ini\n    sess := session.Default(ctx)\n\n}\n</code></pre>"},{"location":"basics/session/#mendapatkan-data","title":"Mendapatkan data","text":"<p>Data dari session dapat diperoleh dari method <code>Get()</code> dari instance session. Method tersebut mengembalikan dua nilai, yaitu data yang ada dan sebuah <code>boolean</code> yang menunjukkan apakah key yang diberikan ada di dalam session tersebut.</p> <pre><code>package something\n\nimport \"its.ac.id/base-go/pkg/session\"\n\nfunc Handler(ctx *gin.Context) {\n    // Mendapatkan instance dari session saat ini\n    sess := session.Default(ctx)\n\n    // Mendapatkan data dari session dengan key `user`\n    user, exists := sess.Get(\"user\")\n}\n</code></pre>"},{"location":"basics/session/#menyimpan-data","title":"Menyimpan Data","text":"<p>Untuk menyimpan data ke session, Anda dapat menggunakan method <code>Set()</code> pada instance session dengan memberikan argumen yaitu key dan value.</p> <pre><code>package something\n\nimport \"its.ac.id/base-go/pkg/session\"\n\nfunc Handler(ctx *gin.Context) {\n    // Mendapatkan instance dari session saat ini\n    sess := session.Default(ctx)\n\n    // Menyimpan ke session\n    sess.Set(\"user.name\", \"DPTSI ITS\")\n    sess.Set(\"user.id\", 11)\n\n    // Setiap melakukan perubahan, wajib memanggil method `Save()` setidaknya sekali.\n    // Umumnya dipanggil sekali setelah semua action yang mengubah session telah dipanggil.\n    if err := sess.Save(); err != nil {\n        ctx.JSON(http.StatusInternalServerError, gin.H{\n            \"code\":    http.StatusInternalServerError,\n            \"message\": \"unable_to_save_session\",\n            \"data\":    nil,\n        })\n        return\n    }\n}\n</code></pre>"},{"location":"basics/session/#menghapus-data","title":"Menghapus Data","text":"<p>Method <code>Delete()</code> dapat digunakan untuk menghapus data dengan key tertentu dari session.</p> <pre><code>package something\n\nimport \"its.ac.id/base-go/pkg/session\"\n\nfunc Handler(ctx *gin.Context) {\n    // Mendapatkan instance dari session saat ini\n    sess := session.Default(ctx)\n\n    // Menghapus dari session\n    sess.Delete(\"user.name\")\n    sess.Delete(\"user.id\")\n\n    // Setiap melakukan perubahan, wajib memanggil method `Save()` setidaknya sekali.\n    // Umumnya dipanggil sekali setelah semua action yang mengubah session telah dipanggil.\n    if err := sess.Save(); err != nil {\n        ctx.JSON(http.StatusInternalServerError, gin.H{\n            \"code\":    http.StatusInternalServerError,\n            \"message\": \"unable_to_save_session\",\n            \"data\":    nil,\n        })\n        return\n    }\n}\n</code></pre>"},{"location":"basics/session/#regenerate-session-id","title":"Regenerate Session ID","text":"<p>Proses ini dilakukan untuk menghindari eksploitasi dengan Session fixation pada aplikasi. Pada umumnya, hal ini dilakukan ketika ada perubahan privilege dari user, contohnya adalah ketika user berhasil login atau mengganti role.</p> <pre><code>package something\n\nimport \"its.ac.id/base-go/pkg/session\"\n\nfunc Handler(ctx *gin.Context) {\n    // Mendapatkan instance dari session saat ini\n    sess := session.Default(ctx)\n\n    // Regenerate session ID\n    sess.Regenerate()\n\n    // Setiap melakukan perubahan, wajib memanggil method `Save()` setidaknya sekali.\n    // Umumnya dipanggil sekali setelah semua action yang mengubah session telah dipanggil.\n    if err := sess.Save(); err != nil {\n        ctx.JSON(http.StatusInternalServerError, gin.H{\n            \"code\":    http.StatusInternalServerError,\n            \"message\": \"unable_to_save_session\",\n            \"data\":    nil,\n        })\n        return\n    }\n\n    // Fungsi ini wajib dipanggil untuk mengganti session ID yang ada pada cookie dengan nilai baru yang digenerate\n    session.AddCookieToResponse(ctx, sess.Id())\n}\n</code></pre>"},{"location":"basics/session/#menambahkan-custom-session-adapter","title":"Menambahkan Custom Session Adapter","text":""},{"location":"basics/session/#mengimplementasikan-adapter","title":"Mengimplementasikan Adapter","text":"<p>Jika adapter yang sudah disediakan tidak memenuhi kriteria Anda, maka Anda perlu mengimplementasikan adapter yang memenuhi kontrak sebagai berikut:</p> <pre><code>type Storage interface {\n    // Membaca instance dari session data dari penyimpanan\n    Get(ctx *gin.Context, id string) (*Data, error)\n    // Menyimpan instance session data ke penyimpanan\n    Save(ctx *gin.Context, id string, data map[string]interface{}, expiredAt time.Time, csrfToken string) error\n    // Menghapus data terkait dengan ID tersebut dari penyimpanan\n    Delete(ctx *gin.Context, id string) error\n}\n</code></pre>"},{"location":"basics/session/#mendaftarkan-adapter","title":"Mendaftarkan Adapter","text":"<p>Anda dapat melakukan inject adapter tersebut pada fungsi <code>init()</code> di berkas <code>bootstrap/web/web.go</code>.</p> <pre><code>func init() {\n    do.Provide[session.Storage](e.Msg, func(i *do.Injector) (session.Storage, error) {\n        // Return implementasi dari adapter\n    })\n}\n</code></pre>"}]}